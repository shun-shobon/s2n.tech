---
title: TypeScriptの型システムを理解して型安全なコードを書こう
tags:
  - TypeScript
  - JavaScript
  - 型システム
publishedAt: "2023-08-20"
updatedAt: "2024-01-15"
---

## はじめに

TypeScriptは、JavaScriptに静的型システムを追加した言語です。
型システムを理解することで、バグを未然に防ぎ、より安全で保守性の高いコードを書くことができます。
今回は、TypeScriptの型システムの基本から応用まで詳しく解説していきます。

## 基本的な型

### プリミティブ型

```typescript
// 数値型
let age: number = 25;
let pi: number = 3.14;

// 文字列型
let name: string = "Alice";
let message: string = `Hello, ${name}!`;

// 真偽値型
let isActive: boolean = true;
let isCompleted: boolean = false;

// null と undefined
let nullable: null = null;
let undefinedValue: undefined = undefined;
```

### 配列とタプル

```typescript
// 配列型
let numbers: number[] = [1, 2, 3, 4, 5];
let fruits: Array<string> = ["apple", "banana", "orange"];

// タプル型（固定長で異なる型を持つ配列）
let person: [string, number] = ["Alice", 25];
let coordinate: [number, number, number] = [10, 20, 30];

// 読み取り専用配列
let readonlyNumbers: readonly number[] = [1, 2, 3];
// readonlyNumbers.push(4); // エラー：読み取り専用なので変更不可
```

## オブジェクト型とインターフェース

### オブジェクト型

```typescript
// オブジェクト型の定義
let user: {
	id: number;
	name: string;
	email: string;
	isActive: boolean;
} = {
	id: 1,
	name: "Alice",
	email: "alice@example.com",
	isActive: true,
};

// オプションプロパティ
let config: {
	host: string;
	port?: number; // オプション
	ssl?: boolean; // オプション
} = {
	host: "localhost",
	// port と ssl は省略可能
};
```

### インターフェース

```typescript
interface User {
	readonly id: number; // 読み取り専用
	name: string;
	email: string;
	age?: number; // オプション
}

interface AdminUser extends User {
	permissions: string[];
	lastLogin: Date;
}

const admin: AdminUser = {
	id: 1,
	name: "Admin",
	email: "admin@example.com",
	permissions: ["read", "write", "delete"],
	lastLogin: new Date(),
};
```

## 関数の型

```typescript
// 関数の型定義
function add(a: number, b: number): number {
	return a + b;
}

// アロー関数
const multiply = (a: number, b: number): number => a * b;

// 関数型の変数
let operation: (x: number, y: number) => number;
operation = add;
operation = multiply;

// オプション引数とデフォルト引数
function greet(
	name: string,
	greeting: string = "Hello",
	punctuation?: string,
): string {
	return `${greeting}, ${name}${punctuation || "!"}`;
}

// 残余引数
function sum(...numbers: number[]): number {
	return numbers.reduce((total, num) => total + num, 0);
}

// 高階関数
function createValidator<T>(validator: (value: T) => boolean) {
	return (value: T): boolean => validator(value);
}

const isPositive = createValidator<number>((x) => x > 0);
```

## ユニオン型と交差型

### ユニオン型

```typescript
// ユニオン型（OR の関係）
type Status = "loading" | "success" | "error";
type ID = string | number;

function handleResponse(status: Status) {
	switch (status) {
		case "loading":
			console.log("読み込み中...");
			break;
		case "success":
			console.log("成功しました");
			break;
		case "error":
			console.log("エラーが発生しました");
			break;
	}
}

// 型ガード
function processId(id: ID) {
	if (typeof id === "string") {
		// この中では id は string 型として扱われる
		console.log(id.toUpperCase());
	} else {
		// この中では id は number 型として扱われる
		console.log(id.toFixed(2));
	}
}
```

### 交差型

```typescript
// 交差型（AND の関係）
interface Person {
	name: string;
	age: number;
}

interface Employee {
	employeeId: string;
	department: string;
}

type PersonEmployee = Person & Employee;

const worker: PersonEmployee = {
	name: "Alice",
	age: 30,
	employeeId: "EMP001",
	department: "Engineering",
};
```

## ジェネリクス

```typescript
// ジェネリック関数
function identity<T>(arg: T): T {
	return arg;
}

const stringResult = identity<string>("hello"); // string型
const numberResult = identity<number>(42); // number型
const autoInferred = identity("world"); // 型推論でstring型

// ジェネリックインターフェース
interface ApiResponse<T> {
	data: T;
	status: number;
	message: string;
}

interface User {
	id: number;
	name: string;
	email: string;
}

const userResponse: ApiResponse<User> = {
	data: { id: 1, name: "Alice", email: "alice@example.com" },
	status: 200,
	message: "Success",
};

const usersResponse: ApiResponse<User[]> = {
	data: [
		{ id: 1, name: "Alice", email: "alice@example.com" },
		{ id: 2, name: "Bob", email: "bob@example.com" },
	],
	status: 200,
	message: "Success",
};

// 制約付きジェネリクス
interface Lengthwise {
	length: number;
}

function logLength<T extends Lengthwise>(arg: T): T {
	console.log(arg.length); // length プロパティが保証されている
	return arg;
}

logLength("hello"); // string は length を持つので OK
logLength([1, 2, 3]); // array は length を持つので OK
// logLength(123); // エラー：number は length を持たない
```

## 条件付き型とマップ型

### 条件付き型

```typescript
// 条件付き型
type IsArray<T> = T extends any[] ? true : false;

type Test1 = IsArray<string[]>; // true
type Test2 = IsArray<number>; // false

// Utility Types の実装例
type MyNonNullable<T> = T extends null | undefined ? never : T;

type Example1 = MyNonNullable<string | null>; // string
type Example2 = MyNonNullable<number | undefined>; // number
```

### マップ型

```typescript
// すべてのプロパティをオプションにする
type Partial<T> = {
	[P in keyof T]?: T[P];
};

// すべてのプロパティを必須にする
type Required<T> = {
	[P in keyof T]-?: T[P];
};

// すべてのプロパティを読み取り専用にする
type Readonly<T> = {
	readonly [P in keyof T]: T[P];
};

interface User {
	id: number;
	name: string;
	email: string;
}

type PartialUser = Partial<User>; // すべてオプション
type ReadonlyUser = Readonly<User>; // すべて読み取り専用

// カスタムマップ型
type Stringify<T> = {
	[K in keyof T]: string;
};

type StringifiedUser = Stringify<User>;
// { id: string; name: string; email: string; }
```

## 実践的な型の活用

### API レスポンスの型定義

```typescript
interface BaseResponse {
	status: "success" | "error";
	message: string;
	timestamp: string;
}

interface SuccessResponse<T> extends BaseResponse {
	status: "success";
	data: T;
}

interface ErrorResponse extends BaseResponse {
	status: "error";
	errorCode: string;
	details?: Record<string, any>;
}

type ApiResponse<T> = SuccessResponse<T> | ErrorResponse;

// 使用例
async function fetchUser(id: number): Promise<ApiResponse<User>> {
	try {
		const response = await fetch(`/api/users/${id}`);
		const data = await response.json();

		if (response.ok) {
			return {
				status: "success",
				message: "User fetched successfully",
				timestamp: new Date().toISOString(),
				data: data,
			};
		} else {
			return {
				status: "error",
				message: "Failed to fetch user",
				timestamp: new Date().toISOString(),
				errorCode: "USER_NOT_FOUND",
			};
		}
	} catch (error) {
		return {
			status: "error",
			message: "Network error",
			timestamp: new Date().toISOString(),
			errorCode: "NETWORK_ERROR",
		};
	}
}
```

### 型ガードと型の絞り込み

```typescript
// カスタム型ガード
function isSuccessResponse<T>(
	response: ApiResponse<T>,
): response is SuccessResponse<T> {
	return response.status === "success";
}

function isErrorResponse(
	response: ApiResponse<any>,
): response is ErrorResponse {
	return response.status === "error";
}

// 使用例
async function handleUserFetch(id: number) {
	const response = await fetchUser(id);

	if (isSuccessResponse(response)) {
		// この中では response は SuccessResponse<User> 型
		console.log("User data:", response.data);
	} else if (isErrorResponse(response)) {
		// この中では response は ErrorResponse 型
		console.error("Error:", response.errorCode, response.message);
	}
}
```

## まとめ

TypeScriptの型システムを活用することで：

1. **コンパイル時エラー検出**: 実行前にバグを発見できる
2. **IntelliSense の向上**: IDEでの補完機能が充実する
3. **リファクタリングの安全性**: 型チェックにより安全に変更できる
4. **自己文書化**: 型定義がドキュメントの役割を果たす
5. **チーム開発の効率化**: APIの仕様が明確になる

型システムは最初は複雑に感じるかもしれませんが、慣れてくると開発効率が大幅に向上します。
少しずつ型を活用していき、より安全で保守性の高いコードを書いていきましょう！
