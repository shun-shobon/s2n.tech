---
title: Docker入門 - コンテナ化で開発環境を統一しよう
tags:
  - Docker
  - DevOps
  - コンテナ
publishedAt: "2023-06-12"
updatedAt: "2024-03-08"
---

## はじめに

Dockerは、アプリケーションとその依存関係をコンテナという軽量な仮想環境にパッケージ化する技術です。
「俺の環境では動く」問題を解決し、開発から本番まで一貫した環境を提供してくれます。
今回は、Dockerの基本的な概念と使い方について解説していきます。

## Dockerの基本概念

### コンテナとイメージ

- **イメージ**: アプリケーションの実行に必要なファイルシステム、ライブラリ、設定などをパッケージ化したもの
- **コンテナ**: イメージから作成された実行可能なインスタンス
- **Dockerfile**: イメージを作成するための設計書

```
Dockerfile → イメージ → コンテナ
     ↓         ↓        ↓
   設計書    パッケージ  実行環境
```

## Dockerfileの基本

### 簡単なNode.jsアプリのDockerfile

```dockerfile
# ベースイメージを指定
FROM node:18-alpine

# 作業ディレクトリを設定
WORKDIR /app

# package.jsonとpackage-lock.jsonをコピー
COPY package*.json ./

# 依存関係をインストール
RUN npm ci --only=production

# アプリケーションのソースコードをコピー
COPY . .

# アプリケーションがリッスンするポートを指定
EXPOSE 3000

# アプリケーションを起動
CMD ["npm", "start"]
```

### Dockerfileの最適化

```dockerfile
# マルチステージビルドでイメージサイズを最小化
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

# 本番用の軽量イメージ
FROM node:18-alpine AS production

# セキュリティのため非rootユーザーを作成
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

WORKDIR /app

# 必要なファイルのみをコピー
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/node_modules ./node_modules

# ユーザーを切り替え
USER nextjs

EXPOSE 3000

CMD ["npm", "start"]
```

## 基本的なDockerコマンド

### イメージの操作

```bash
# イメージをビルド
docker build -t my-app:latest .

# イメージの一覧表示
docker images

# イメージを削除
docker rmi my-app:latest

# Docker Hubからイメージを取得
docker pull nginx:alpine

# イメージの詳細情報を表示
docker inspect my-app:latest
```

### コンテナの操作

```bash
# コンテナを起動（フォアグラウンド）
docker run my-app:latest

# コンテナを起動（バックグラウンド）
docker run -d my-app:latest

# ポートマッピングして起動
docker run -d -p 8080:3000 my-app:latest

# 環境変数を設定して起動
docker run -d -e NODE_ENV=production my-app:latest

# ボリュームをマウントして起動
docker run -d -v $(pwd):/app my-app:latest

# 起動中のコンテナ一覧
docker ps

# 停止したコンテナも含めて一覧表示
docker ps -a

# コンテナを停止
docker stop <container-id>

# コンテナを削除
docker rm <container-id>

# コンテナの中でコマンドを実行
docker exec -it <container-id> /bin/sh
```

## Docker Compose

複数のコンテナを組み合わせたアプリケーションを管理するツールです。

### docker-compose.yml の例

```yaml
version: "3.8"

services:
  # Webアプリケーション
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgres://user:password@db:5432/myapp
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - db
      - redis

  # データベース
  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # Nginx（リバースプロキシ）
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - web

volumes:
  postgres_data:
  redis_data:
```

### Docker Composeコマンド

```bash
# サービスを起動（バックグラウンド）
docker-compose up -d

# サービスを起動（フォアグラウンド）
docker-compose up

# 特定のサービスのみ起動
docker-compose up web

# サービスを停止
docker-compose down

# サービスを再起動
docker-compose restart

# ログを確認
docker-compose logs

# 特定のサービスのログを確認
docker-compose logs web

# サービスの状態を確認
docker-compose ps

# サービス内でコマンドを実行
docker-compose exec web /bin/sh
```

## 実践的な開発環境の例

### Next.js + PostgreSQL + Redis の開発環境

```yaml
# docker-compose.dev.yml
version: "3.8"

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgres://postgres:password@db:5432/nextapp
      - REDIS_URL=redis://redis:6379
      - NEXTAUTH_URL=http://localhost:3000
      - NEXTAUTH_SECRET=your-secret-key
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
    depends_on:
      - db
      - redis

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=nextapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data
      - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_dev_data:/data

  mailhog:
    image: mailhog/mailhog
    ports:
      - "1025:1025" # SMTP
      - "8025:8025" # Web UI

volumes:
  postgres_dev_data:
  redis_dev_data:
```

### 開発用Dockerfile

```dockerfile
# Dockerfile.dev
FROM node:18-alpine

WORKDIR /app

# 開発に必要なパッケージをインストール
RUN apk add --no-cache libc6-compat

# パッケージファイルをコピー
COPY package*.json ./

# 開発依存関係も含めてインストール
RUN npm ci

# ソースコードをコピー
COPY . .

# 開発サーバーを起動
CMD ["npm", "run", "dev"]
```

## ベストプラクティス

### セキュリティ

```dockerfile
# 1. 非rootユーザーを使用
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001
USER nextjs

# 2. 最小限のベースイメージを使用
FROM node:18-alpine

# 3. 不要なファイルを除外
# .dockerignoreファイルを作成
```

`.dockerignore`の例：

```
node_modules
npm-debug.log
.next
.git
.gitignore
README.md
Dockerfile
.dockerignore
```

### パフォーマンス最適化

```dockerfile
# レイヤーキャッシュを活用
COPY package*.json ./
RUN npm ci --only=production

# 後でソースコードをコピー
COPY . .

# マルチステージビルドでサイズ削減
FROM node:18-alpine AS deps
# 依存関係のインストール

FROM node:18-alpine AS builder
# アプリケーションのビルド

FROM node:18-alpine AS runner
# 実行時に必要なファイルのみ
```

## トラブルシューティング

### よくある問題と解決方法

```bash
# コンテナが起動しない場合
docker logs <container-id>

# ポートが使用中の場合
docker ps
lsof -i :3000

# ディスク容量不足の場合
docker system prune -f
docker volume prune -f

# イメージが見つからない場合
docker pull <image-name>

# 権限エラーの場合
sudo usermod -aG docker $USER
# ログアウト・ログインが必要
```

## 終わりに

Dockerを使うことで：

1. **環境の統一**: 開発・ステージング・本番で同じ環境を使用
2. **依存関係の分離**: アプリケーション間での競合を防止
3. **スケーラビリティ**: 必要に応じてコンテナを増減
4. **ポータビリティ**: どこでも同じように動作

最初は複雑に感じるかもしれませんが、一度慣れてしまえば開発効率が大幅に向上します。
小さなプロジェクトから始めて、徐々にDockerの力を活用していきましょう！
