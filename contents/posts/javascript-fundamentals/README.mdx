---
title: JavaScript基礎完全マスター - モダン開発への第一歩
tags:
  - JavaScript
  - ES6+
  - 基礎
  - プログラミング
publishedAt: "2023-01-10"
---

## はじめに

JavaScriptは現代のWeb開発において欠かせない言語です。
ブラウザだけでなく、Node.jsによってサーバーサイド開発でも広く使われています。
この記事では、JavaScriptの基礎から現代的な記法まで、しっかりとした土台を築けるよう丁寧に解説していきます。

## 変数とデータ型

### 変数の宣言

```javascript
// var（古い記法、避ける）
var oldWay = "古い方法";

// let（再代入可能）
let mutableVariable = "変更可能";
mutableVariable = "新しい値";

// const（再代入不可）
const immutableVariable = "変更不可";
// immutableVariable = "エラー"; // TypeError

// オブジェクトや配列の場合は中身は変更可能
const obj = { name: "Alice" };
obj.name = "Bob"; // OK
obj.age = 25; // OK
```

### プリミティブ型

```javascript
// 文字列（String）
const str1 = "ダブルクォート";
const str2 = "シングルクォート";
const str3 = `テンプレートリテラル: ${str1}`;

// 数値（Number）
const integer = 42;
const float = 3.14;
const scientific = 1.5e10; // 1.5 × 10^10

// 真偽値（Boolean）
const isTrue = true;
const isFalse = false;

// null と undefined
const nullValue = null;
let undefinedValue; // undefined
const explicitUndefined = undefined;

// Symbol（ES6+）
const symbol1 = Symbol("description");
const symbol2 = Symbol("description");
console.log(symbol1 === symbol2); // false

// BigInt（ES2020）
const bigNumber = 1234567890123456789012345678901234567890n;
const anotherBig = BigInt("1234567890123456789012345678901234567890");
```

### 参照型

```javascript
// オブジェクト
const person = {
	name: "Alice",
	age: 30,
	city: "Tokyo",
	// メソッド
	greet() {
		return `Hello, I'm ${this.name}`;
	},
	// ゲッター
	get info() {
		return `${this.name} (${this.age})`;
	},
	// セッター
	set fullName(value) {
		[this.firstName, this.lastName] = value.split(" ");
	},
};

// 配列
const numbers = [1, 2, 3, 4, 5];
const mixed = [1, "hello", true, null, { key: "value" }];
const matrix = [
	[1, 2],
	[3, 4],
	[5, 6],
];

// 関数
function regularFunction(param) {
	return param * 2;
}

const arrowFunction = (param) => param * 2;
const oneLineArrow = (param) => param * 2; // 引数が1つの場合は括弧省略可
```

## 演算子と制御構文

### 算術演算子

```javascript
const a = 10;
const b = 3;

console.log(a + b); // 13 (加算)
console.log(a - b); // 7  (減算)
console.log(a * b); // 30 (乗算)
console.log(a / b); // 3.333... (除算)
console.log(a % b); // 1  (剰余)
console.log(a ** b); // 1000 (べき乗, ES2016)

// インクリメント・デクリメント
let counter = 0;
console.log(counter++); // 0 (後置)
console.log(++counter); // 2 (前置)
console.log(counter--); // 2 (後置)
console.log(--counter); // 0 (前置)
```

### 比較演算子

```javascript
// 等価・厳密等価
console.log(5 == "5"); // true (型変換あり)
console.log(5 === "5"); // false (厳密比較)
console.log(5 != "5"); // false
console.log(5 !== "5"); // true

// 大小比較
console.log(10 > 5); // true
console.log(10 >= 10); // true
console.log(5 < 10); // true
console.log(5 <= 5); // true
```

### 論理演算子

```javascript
const x = true;
const y = false;

// AND
console.log(x && y); // false
console.log(true && "hello"); // "hello"
console.log(false && "hello"); // false

// OR
console.log(x || y); // true
console.log(false || "default"); // "default"
console.log(true || "default"); // true

// NOT
console.log(!x); // false
console.log(!y); // true
console.log(!!x); // true (Boolean変換)

// Nullish Coalescing (ES2020)
const value = null;
console.log(value ?? "default"); // "default"
console.log(0 ?? "default"); // 0 (0はnullishではない)
```

### 条件分岐

```javascript
// if文
const score = 85;

if (score >= 90) {
	console.log("優秀");
} else if (score >= 70) {
	console.log("良好");
} else if (score >= 60) {
	console.log("合格");
} else {
	console.log("不合格");
}

// 三項演算子
const result = score >= 60 ? "合格" : "不合格";
const grade = score >= 90 ? "A" : score >= 80 ? "B" : score >= 70 ? "C" : "D";

// switch文
const day = "月曜日";
switch (day) {
	case "月曜日":
	case "火曜日":
	case "水曜日":
	case "木曜日":
	case "金曜日":
		console.log("平日");
		break;
	case "土曜日":
	case "日曜日":
		console.log("週末");
		break;
	default:
		console.log("不明");
}
```

### ループ処理

```javascript
// for文
for (let i = 0; i < 5; i++) {
	console.log(i); // 0, 1, 2, 3, 4
}

// for...in（オブジェクトのキーを反復）
const obj = { a: 1, b: 2, c: 3 };
for (const key in obj) {
	console.log(`${key}: ${obj[key]}`);
}

// for...of（配列やイテラブルの値を反復）
const arr = ["apple", "banana", "cherry"];
for (const item of arr) {
	console.log(item);
}

// while文
let count = 0;
while (count < 3) {
	console.log(`カウント: ${count}`);
	count++;
}

// do...while文
let num = 0;
do {
	console.log(`数値: ${num}`);
	num++;
} while (num < 3);
```

## 関数

### 関数の基本

```javascript
// 関数宣言
function add(a, b) {
	return a + b;
}

// 関数式
const multiply = function (a, b) {
	return a * b;
};

// アロー関数
const divide = (a, b) => {
	return a / b;
};

// 短縮記法
const square = (x) => x * x;
const greet = (name) => `Hello, ${name}!`;
```

### 高度な関数機能

```javascript
// デフォルトパラメータ
function createUser(name, age = 18, city = "Unknown") {
	return { name, age, city };
}

console.log(createUser("Alice")); // { name: "Alice", age: 18, city: "Unknown" }
console.log(createUser("Bob", 25, "Tokyo")); // { name: "Bob", age: 25, city: "Tokyo" }

// レストパラメータ
function sum(...numbers) {
	return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// 分割代入
function processUser({ name, age, email = "not provided" }) {
	console.log(`${name} (${age}) - ${email}`);
}

processUser({ name: "Alice", age: 30 }); // Alice (30) - not provided

// 高階関数
function createMultiplier(factor) {
	return function (number) {
		return number * factor;
	};
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

## 配列操作

### 基本的な配列メソッド

```javascript
const fruits = ["apple", "banana", "cherry"];

// 要素の追加・削除
fruits.push("date"); // 末尾に追加
fruits.unshift("apricot"); // 先頭に追加
const lastFruit = fruits.pop(); // 末尾から削除して返す
const firstFruit = fruits.shift(); // 先頭から削除して返す

// インデックス操作
console.log(fruits[0]); // 最初の要素
console.log(fruits[fruits.length - 1]); // 最後の要素
console.log(fruits.indexOf("banana")); // インデックスを取得
console.log(fruits.includes("cherry")); // 存在確認

// スライス
const sliced = fruits.slice(1, 3); // インデックス1から3未満
const spliced = fruits.splice(1, 2, "orange", "grape"); // 削除と挿入
```

### 関数型プログラミングメソッド

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// map - 各要素を変換
const doubled = numbers.map((n) => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

// filter - 条件に合う要素を抽出
const evens = numbers.filter((n) => n % 2 === 0);
console.log(evens); // [2, 4, 6, 8, 10]

// reduce - 配列を単一の値に集約
const sum = numbers.reduce((acc, curr) => acc + curr, 0);
console.log(sum); // 55

const max = numbers.reduce((acc, curr) => Math.max(acc, curr));
console.log(max); // 10

// find - 条件に合う最初の要素
const firstEven = numbers.find((n) => n % 2 === 0);
console.log(firstEven); // 2

// some / every - 条件チェック
const hasEven = numbers.some((n) => n % 2 === 0); // true
const allPositive = numbers.every((n) => n > 0); // true

// forEach - 各要素で処理実行
numbers.forEach((num, index) => {
	console.log(`Index ${index}: ${num}`);
});
```

### 配列の結合と分割

```javascript
// スプレッド演算子
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// 配列のコピー
const original = [1, 2, 3];
const copy = [...original]; // シャローコピー

// 分割代入
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]

// スワップ
let a = 1,
	b = 2;
[a, b] = [b, a];
console.log(a, b); // 2, 1
```

## オブジェクト操作

### オブジェクトの基本操作

```javascript
const person = {
	name: "Alice",
	age: 30,
	city: "Tokyo",
};

// プロパティアクセス
console.log(person.name); // ドット記法
console.log(person["age"]); // ブラケット記法

// 動的なプロパティ名
const key = "city";
console.log(person[key]); // Tokyo

// プロパティの追加・変更・削除
person.email = "alice@example.com"; // 追加
person.age = 31; // 変更
delete person.city; // 削除

// プロパティの存在確認
console.log("name" in person); // true
console.log(person.hasOwnProperty("name")); // true
```

### ES6+のオブジェクト機能

```javascript
const name = "Bob";
const age = 25;

// プロパティの短縮記法
const user = { name, age }; // { name: "Bob", age: 25 }

// 計算されたプロパティ名
const dynamicKey = "userRole";
const userWithRole = {
	name,
	age,
	[dynamicKey]: "admin", // userRole: "admin"
	[`${name}_id`]: 12345, // Bob_id: 12345
};

// メソッドの短縮記法
const calculator = {
	// 従来の記法
	add: function (a, b) {
		return a + b;
	},
	// 短縮記法
	subtract(a, b) {
		return a - b;
	},
	// アロー関数（thisが異なる）
	multiply: (a, b) => a * b,
};
```

### オブジェクトの分割代入

```javascript
const user = {
	id: 1,
	name: "Alice",
	email: "alice@example.com",
	address: {
		city: "Tokyo",
		country: "Japan",
	},
};

// 基本的な分割代入
const { name, email } = user;

// エイリアス
const { name: userName, id: userId } = user;

// デフォルト値
const { phone = "not provided" } = user;

// ネストした分割代入
const {
	address: { city, country },
} = user;

// 関数のパラメータでの分割代入
function displayUser({ name, email, age = "unknown" }) {
	console.log(`${name} (${age}) - ${email}`);
}

displayUser(user); // Alice (unknown) - alice@example.com
```

### オブジェクトのコピーとマージ

```javascript
const original = { a: 1, b: 2 };

// シャローコピー
const copy1 = { ...original };
const copy2 = Object.assign({}, original);

// マージ
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };
const merged = { ...obj1, ...obj2 }; // { a: 1, b: 3, c: 4 }

// ディープコピー（ネストしたオブジェクト）
const nested = {
	user: { name: "Alice" },
	scores: [90, 85, 92],
};

// JSON経由（関数やDateオブジェクトは失われる）
const deepCopy1 = JSON.parse(JSON.stringify(nested));

// 手動でのディープコピー関数
function deepClone(obj) {
	if (obj === null || typeof obj !== "object") return obj;
	if (obj instanceof Date) return new Date(obj);
	if (obj instanceof Array) return obj.map((item) => deepClone(item));
	if (typeof obj === "object") {
		const cloned = {};
		for (const key in obj) {
			if (obj.hasOwnProperty(key)) {
				cloned[key] = deepClone(obj[key]);
			}
		}
		return cloned;
	}
}
```

## 非同期処理

### コールバック

```javascript
// 従来のコールバックパターン
function fetchData(callback) {
	setTimeout(() => {
		const data = { id: 1, name: "Sample Data" };
		callback(null, data); // エラー, データ
	}, 1000);
}

fetchData((error, data) => {
	if (error) {
		console.error("エラー:", error);
	} else {
		console.log("データ:", data);
	}
});
```

### Promise

```javascript
// Promiseの作成
function fetchUserData(userId) {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
			if (userId > 0) {
				resolve({ id: userId, name: `User ${userId}` });
			} else {
				reject(new Error("無効なユーザーID"));
			}
		}, 1000);
	});
}

// Promiseの使用
fetchUserData(1)
	.then((user) => {
		console.log("ユーザー:", user);
		return fetchUserData(2); // チェーン
	})
	.then((user2) => {
		console.log("ユーザー2:", user2);
	})
	.catch((error) => {
		console.error("エラー:", error);
	})
	.finally(() => {
		console.log("処理完了");
	});

// Promise.all（並列実行）
Promise.all([fetchUserData(1), fetchUserData(2), fetchUserData(3)])
	.then((users) => {
		console.log("全ユーザー:", users);
	})
	.catch((error) => {
		console.error("いずれかでエラー:", error);
	});

// Promise.race（最初に完了したもの）
Promise.race([fetchUserData(1), fetchUserData(2)]).then((firstUser) => {
	console.log("最初のユーザー:", firstUser);
});
```

### async/await

```javascript
// async関数の定義
async function getUserData(userId) {
	try {
		const user = await fetchUserData(userId);
		console.log("取得したユーザー:", user);
		return user;
	} catch (error) {
		console.error("ユーザー取得エラー:", error);
		throw error;
	}
}

// 複数の非同期処理
async function processMultipleUsers() {
	try {
		// 順次実行
		const user1 = await fetchUserData(1);
		const user2 = await fetchUserData(2);

		// 並列実行
		const [user3, user4] = await Promise.all([
			fetchUserData(3),
			fetchUserData(4),
		]);

		return [user1, user2, user3, user4];
	} catch (error) {
		console.error("エラー:", error);
	}
}

// トップレベルawait（ES2022, モジュール内でのみ）
// const userData = await getUserData(1);
```

## モジュールシステム

### ES Modules

```javascript
// math.js - エクスポート
export const PI = 3.14159;

export function add(a, b) {
	return a + b;
}

export function multiply(a, b) {
	return a * b;
}

// デフォルトエクスポート
export default function subtract(a, b) {
	return a - b;
}

// main.js - インポート
import subtract, { PI, add, multiply } from "./math.js";
import * as math from "./math.js"; // 名前空間インポート

console.log(PI); // 3.14159
console.log(add(2, 3)); // 5
console.log(subtract(5, 2)); // 3
console.log(math.multiply(3, 4)); // 12

// 動的インポート
async function loadModule() {
	const mathModule = await import("./math.js");
	console.log(mathModule.add(1, 2));
}
```

## エラーハンドリング

### try-catch文

```javascript
function riskyOperation(value) {
	if (value < 0) {
		throw new Error("負の値は許可されていません");
	}
	if (typeof value !== "number") {
		throw new TypeError("数値である必要があります");
	}
	return Math.sqrt(value);
}

try {
	const result1 = riskyOperation(16);
	console.log("結果:", result1); // 4

	const result2 = riskyOperation(-1); // エラーが発生
	console.log("この行は実行されない");
} catch (error) {
	if (error instanceof TypeError) {
		console.error("型エラー:", error.message);
	} else {
		console.error("一般的なエラー:", error.message);
	}
} finally {
	console.log("cleanup処理"); // 必ず実行される
}
```

### カスタムエラー

```javascript
class CustomError extends Error {
	constructor(message, code) {
		super(message);
		this.name = "CustomError";
		this.code = code;
	}
}

class ValidationError extends Error {
	constructor(field, value) {
		super(`Validation failed for field: ${field}`);
		this.name = "ValidationError";
		this.field = field;
		this.value = value;
	}
}

// 使用例
function validateUser(user) {
	if (!user.email) {
		throw new ValidationError("email", user.email);
	}
	if (user.age < 0) {
		throw new CustomError("年齢は負の値にできません", "INVALID_AGE");
	}
}
```

## 実践的なパターン

### 即座実行関数式（IIFE）

```javascript
// プライベートスコープの作成
(function () {
	const privateVariable = "外からアクセスできない";

	window.MyModule = {
		publicMethod: function () {
			return privateVariable;
		},
	};
})();

// アロー関数版
(() => {
	const config = { apiUrl: "https://api.example.com" };
	// 初期化処理
})();
```

### クロージャ

```javascript
function createCounter(initialValue = 0) {
	let count = initialValue;

	return {
		increment: () => ++count,
		decrement: () => --count,
		getValue: () => count,
		reset: () => {
			count = initialValue;
		},
	};
}

const counter = createCounter(10);
console.log(counter.getValue()); // 10
console.log(counter.increment()); // 11
console.log(counter.decrement()); // 10
counter.reset();
console.log(counter.getValue()); // 10
```

### デバウンスとスロットル

```javascript
// デバウンス（連続した呼び出しを制御）
function debounce(func, delay) {
	let timeoutId;
	return function (...args) {
		clearTimeout(timeoutId);
		timeoutId = setTimeout(() => func.apply(this, args), delay);
	};
}

// スロットル（一定間隔で実行）
function throttle(func, limit) {
	let inThrottle;
	return function (...args) {
		if (!inThrottle) {
			func.apply(this, args);
			inThrottle = true;
			setTimeout(() => (inThrottle = false), limit);
		}
	};
}

// 使用例
const debouncedSearch = debounce((query) => {
	console.log("検索:", query);
}, 300);

const throttledScroll = throttle(() => {
	console.log("スクロール処理");
}, 100);
```

## まとめ

この記事では、JavaScriptの基礎から実践的なパターンまでを幅広く解説しました。

**重要なポイント**：

1. **モダンな記法を使う**: let/const, アロー関数, テンプレートリテラル
2. **非同期処理を理解する**: Promise, async/await
3. **関数型プログラミングを活用**: map, filter, reduce
4. **エラーハンドリングを適切に行う**: try-catch, カスタムエラー
5. **モジュールシステムを活用**: ES Modules

これらの基礎をしっかりと身につけることで、React、Vue.js、Node.jsなどのフレームワークやライブラリをより深く理解できるようになります。

継続的な学習と実践を通じて、JavaScriptのスキルを向上させていきましょう！
