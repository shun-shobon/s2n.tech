---
title: マイクロサービス設計の実践ガイド - 大規模Webアプリケーションを分割統治する
tags:
  - マイクロサービス
  - アーキテクチャ
  - スケーラビリティ
  - Backend
  - DevOps
updatedAt: "2024-07-15"
---

## はじめに

現代の大規模Webアプリケーション開発において、マイクロサービスアーキテクチャは重要な選択肢となっています。
モノリシックなアプリケーションから個別のサービスに分割することで、
開発チームの独立性、技術スタックの柔軟性、スケーラビリティの向上を実現できます。
今回は、実際の事例とともにマイクロサービス設計の実践的なアプローチを詳しく解説します。

> **注意**: この記事は現在執筆中の下書きです。内容は予告なく変更される可能性があります。

## マイクロサービスの基本概念

### モノリスとマイクロサービスの比較

```
モノリシック アーキテクチャ:
┌─────────────────────────────────┐
│         Single Application      │
│  ┌─────┐ ┌─────┐ ┌─────────┐  │
│  │ UI  │ │Auth │ │Business │  │
│  │     │ │     │ │ Logic   │  │
│  └─────┘ └─────┘ └─────────┘  │
│           Database              │
└─────────────────────────────────┘

マイクロサービス アーキテクチャ:
┌─────────┐ ┌─────────┐ ┌─────────┐
│ User    │ │ Auth    │ │ Order   │
│ Service │ │ Service │ │ Service │
│   +DB   │ │   +DB   │ │   +DB   │
└─────────┘ └─────────┘ └─────────┘
     │           │           │
     └───────────┼───────────┘
                 │
        ┌─────────────────┐
        │  API Gateway    │
        └─────────────────┘
```

### マイクロサービスの利点

1. **技術の自由度**: サービスごとに最適な技術スタックを選択
2. **独立したデプロイ**: 他のサービスに影響を与えずにリリース
3. **スケーラビリティ**: 必要なサービスのみスケールアウト
4. **障害の局所化**: 一つのサービスの障害が全体に波及しない
5. **チームの独立性**: 小さなチームで迅速な開発

### 検討すべき課題

1. **複雑性の増加**: ネットワーク通信、分散トランザクション
2. **運用コスト**: 複数のサービスの監視、ログ管理
3. **データの整合性**: 分散システムでの整合性保証
4. **テストの複雑化**: サービス間の統合テスト

## サービス分割の戦略

### ドメイン駆動設計（DDD）による分割

```typescript
// User Domain（ユーザー管理）
interface UserService {
	createUser(userData: CreateUserRequest): Promise<User>;
	getUser(userId: string): Promise<User>;
	updateUser(userId: string, updates: UpdateUserRequest): Promise<User>;
	deleteUser(userId: string): Promise<void>;
}

// Order Domain（注文管理）
interface OrderService {
	createOrder(orderData: CreateOrderRequest): Promise<Order>;
	getOrder(orderId: string): Promise<Order>;
	updateOrderStatus(orderId: string, status: OrderStatus): Promise<Order>;
	getOrdersByUser(userId: string): Promise<Order[]>;
}

// Product Domain（商品管理）
interface ProductService {
	createProduct(productData: CreateProductRequest): Promise<Product>;
	getProduct(productId: string): Promise<Product>;
	updateProduct(
		productId: string,
		updates: UpdateProductRequest,
	): Promise<Product>;
	searchProducts(criteria: SearchCriteria): Promise<Product[]>;
}
```

### 境界付きコンテキストの定義

```typescript
// User Context
export class User {
	constructor(
		public readonly id: UserId,
		public readonly email: Email,
		public readonly profile: UserProfile,
		public readonly createdAt: Date,
	) {}
}

// Order Context（異なるUserの表現）
export class OrderCustomer {
	constructor(
		public readonly customerId: CustomerId,
		public readonly name: string,
		public readonly shippingAddress: Address,
	) {}
}
```

## API設計とサービス間通信

### RESTful API設計

```typescript
// User Service API
export class UserController {
	@Get("/users/:id")
	async getUser(@Param("id") id: string): Promise<UserResponse> {
		const user = await this.userService.getUser(id);
		return this.toUserResponse(user);
	}

	@Post("/users")
	async createUser(@Body() request: CreateUserRequest): Promise<UserResponse> {
		const user = await this.userService.createUser(request);
		return this.toUserResponse(user);
	}

	@Put("/users/:id")
	async updateUser(
		@Param("id") id: string,
		@Body() request: UpdateUserRequest,
	): Promise<UserResponse> {
		const user = await this.userService.updateUser(id, request);
		return this.toUserResponse(user);
	}
}
```

### イベント駆動アーキテクチャ

```typescript
// ドメインイベントの定義
export interface DomainEvent {
	eventId: string;
	eventType: string;
	aggregateId: string;
	timestamp: Date;
	version: number;
}

export class UserCreatedEvent implements DomainEvent {
	constructor(
		public readonly eventId: string,
		public readonly aggregateId: string,
		public readonly userEmail: string,
		public readonly timestamp: Date,
		public readonly version: number,
	) {}

	eventType = "UserCreated";
}

// イベントパブリッシャー
export class EventBus {
	async publish(event: DomainEvent): Promise<void> {
		await this.messageQueue.send({
			topic: event.eventType,
			message: JSON.stringify(event),
			partition: event.aggregateId,
		});
	}
}

// イベントハンドラー
export class OrderEventHandler {
	@EventHandler("UserCreated")
	async handleUserCreated(event: UserCreatedEvent): Promise<void> {
		// 注文サービス側でユーザー情報のコピーを作成
		await this.orderService.createCustomerProfile({
			customerId: event.aggregateId,
			email: event.userEmail,
		});
	}
}
```

### サーキットブレーカーパターン

```typescript
export class CircuitBreaker {
	private state: "CLOSED" | "OPEN" | "HALF_OPEN" = "CLOSED";
	private failureCount = 0;
	private lastFailureTime?: Date;

	constructor(
		private readonly failureThreshold: number = 5,
		private readonly timeoutDuration: number = 60000,
	) {}

	async execute<T>(operation: () => Promise<T>): Promise<T> {
		if (this.state === "OPEN") {
			if (this.shouldAttemptReset()) {
				this.state = "HALF_OPEN";
			} else {
				throw new Error("Circuit breaker is OPEN");
			}
		}

		try {
			const result = await operation();
			this.onSuccess();
			return result;
		} catch (error) {
			this.onFailure();
			throw error;
		}
	}

	private onSuccess(): void {
		this.failureCount = 0;
		this.state = "CLOSED";
	}

	private onFailure(): void {
		this.failureCount++;
		this.lastFailureTime = new Date();

		if (this.failureCount >= this.failureThreshold) {
			this.state = "OPEN";
		}
	}

	private shouldAttemptReset(): boolean {
		return (
			this.lastFailureTime &&
			Date.now() - this.lastFailureTime.getTime() > this.timeoutDuration
		);
	}
}
```

## データ管理戦略

### Database per Service

```typescript
// User Service Database
export class UserRepository {
	constructor(private readonly userDb: Database) {}

	async save(user: User): Promise<void> {
		await this.userDb.users.insert({
			id: user.id.value,
			email: user.email.value,
			profile: user.profile.toJSON(),
			created_at: user.createdAt,
		});
	}

	async findById(id: UserId): Promise<User | null> {
		const userData = await this.userDb.users.findOne({ id: id.value });
		return userData ? User.fromJSON(userData) : null;
	}
}

// Order Service Database（独立したデータベース）
export class OrderRepository {
	constructor(private readonly orderDb: Database) {}

	async save(order: Order): Promise<void> {
		await this.orderDb.orders.insert({
			id: order.id.value,
			customer_id: order.customerId.value,
			items: order.items.map((item) => item.toJSON()),
			status: order.status,
			created_at: order.createdAt,
		});
	}
}
```

### Sagaパターンによる分散トランザクション

```typescript
export class OrderSaga {
	async processOrder(command: CreateOrderCommand): Promise<void> {
		const sagaId = generateId();

		try {
			// Step 1: 在庫確保
			const reservationResult = await this.inventoryService.reserveItems(
				command.items,
				sagaId,
			);

			// Step 2: 決済処理
			const paymentResult = await this.paymentService.processPayment(
				command.paymentInfo,
				sagaId,
			);

			// Step 3: 注文作成
			const order = await this.orderService.createOrder(command, sagaId);

			// 全てのステップが成功
			await this.commitSaga(sagaId);
		} catch (error) {
			// エラー時は補償トランザクションを実行
			await this.rollbackSaga(sagaId, error);
			throw error;
		}
	}

	private async rollbackSaga(sagaId: string, error: Error): Promise<void> {
		// 逆順で補償処理を実行
		await this.orderService.cancelOrder(sagaId);
		await this.paymentService.refundPayment(sagaId);
		await this.inventoryService.releaseReservation(sagaId);
	}
}
```

## 分散システムの監視と運用

### 分散トレーシング

```typescript
import { trace, context } from "@opentelemetry/api";

export class UserService {
	private tracer = trace.getTracer("user-service");

	async getUser(userId: string): Promise<User> {
		return this.tracer.startActiveSpan("get-user", async (span) => {
			span.setAttributes({
				"user.id": userId,
				"service.name": "user-service",
			});

			try {
				const user = await this.userRepository.findById(new UserId(userId));

				if (!user) {
					span.setStatus({
						code: SpanStatusCode.ERROR,
						message: "User not found",
					});
					throw new UserNotFoundError(userId);
				}

				span.setAttributes({
					"user.email": user.email.value,
					"user.created_at": user.createdAt.toISOString(),
				});

				return user;
			} catch (error) {
				span.recordException(error);
				span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
				throw error;
			} finally {
				span.end();
			}
		});
	}
}
```

### メトリクス収集

```typescript
import { metrics } from "@opentelemetry/api-metrics";

export class MetricsCollector {
	private meter = metrics.getMeter("order-service");
	private orderCounter = this.meter.createCounter("orders_total");
	private orderDuration = this.meter.createHistogram("order_duration_seconds");

	recordOrderCreated(status: string): void {
		this.orderCounter.add(1, { status });
	}

	recordOrderDuration(duration: number, status: string): void {
		this.orderDuration.record(duration, { status });
	}
}

export class OrderService {
	constructor(
		private readonly orderRepository: OrderRepository,
		private readonly metrics: MetricsCollector,
	) {}

	async createOrder(command: CreateOrderCommand): Promise<Order> {
		const startTime = Date.now();

		try {
			const order = new Order(command);
			await this.orderRepository.save(order);

			this.metrics.recordOrderCreated("success");
			this.metrics.recordOrderDuration(
				(Date.now() - startTime) / 1000,
				"success",
			);

			return order;
		} catch (error) {
			this.metrics.recordOrderCreated("error");
			this.metrics.recordOrderDuration(
				(Date.now() - startTime) / 1000,
				"error",
			);
			throw error;
		}
	}
}
```

## コンテナ化とオーケストレーション

### Docker設定

```dockerfile
# User Service Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY dist/ ./dist/
COPY config/ ./config/

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["node", "dist/main.js"]
```

### Kubernetes配備

```yaml
# user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  labels:
    app: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
        - name: user-service
          image: user-service:latest
          ports:
            - containerPort: 3000
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: user-service-secrets
                  key: database-url
            - name: REDIS_URL
              valueFrom:
                configMapKeyRef:
                  name: user-service-config
                  key: redis-url
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: user-service-service
spec:
  selector:
    app: user-service
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: ClusterIP
```

## テスト戦略

### Contract Testing

```typescript
// Consumer Test (Order Service)
describe("User Service Contract", () => {
	test("should get user by id", async () => {
		const mockUserService = new MockUserService();
		mockUserService.addInteraction({
			state: "user exists",
			uponReceiving: "a request for user",
			withRequest: {
				method: "GET",
				path: "/users/123",
				headers: {
					Accept: "application/json",
				},
			},
			willRespondWith: {
				status: 200,
				headers: {
					"Content-Type": "application/json",
				},
				body: {
					id: "123",
					email: "user@example.com",
					name: "John Doe",
				},
			},
		});

		const orderService = new OrderService(mockUserService);
		const user = await orderService.getCustomerInfo("123");

		expect(user.id).toBe("123");
		expect(user.email).toBe("user@example.com");
	});
});
```

## 今後の執筆予定

この記事では、以下のトピックを追加で執筆予定です：

- [ ] API Gateway の詳細設計
- [ ] Service Mesh（Istio）の活用
- [ ] セキュリティ（認証・認可の分散管理）
- [ ] パフォーマンス最適化
- [ ] 実際の移行事例とレッスンズラーンド

## 参考資料

- Martin Fowler's Microservices Articles
- Building Microservices by Sam Newman
- Kubernetes Official Documentation
- OpenTelemetry Documentation

> この記事の完成版公開をお楽しみに！フィードバックや質問があれば、ぜひコメントでお聞かせください。
